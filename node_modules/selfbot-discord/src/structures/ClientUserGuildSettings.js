const Constants = require('../util/Constants');
const Collection = require('../util/Collection');
const ClientUserChannelOverride = require('./ClientUserChannelOverride');

/**
 * A wrapper around the ClientUser's guild settings.
 */
class ClientUserGuildSettings {
	constructor(data, client) {
		/**
		 * The client that created the instance of the ClientUserGuildSettings
		 * @name ClientUserGuildSettings#client
		 * @type {Client}
		 * @readonly
		 */
		Object.defineProperty(this, 'client', { value: client });
		/**
		 * The ID of the guild this settings are for
		 * @type {Snowflake}
		 */
		this.guildID = data.guild_id;
		this.channelOverrides = new Collection();
		this.patch(data);
	}

	/**
	 * Patch the data contained in this class with new partial data.
	 * @param {Object} data Data to patch this with
	 * @returns {void}
	 * @private
	 */
	patch(data) {
		// if (this.client.status === 0) console.log("[patch] detected");
		for (const key of Object.keys(Constants.UserGuildSettingsMap)) {
			// if (this.client.status === 0) console.log("___");
			const value = Constants.UserGuildSettingsMap[key];
			if (!data.hasOwnProperty(key)) continue;
			if (key === 'channel_overrides') {
				// if (this.client.status === 0) console.log("[patch] override");
				// if (this.client.status === 0) console.log(data[key].find(channel => channel["channel_id"] === "1124664480073252895"));
				// idremoved pas dans la boucle psq l'id sera pas dans data.key ptdrrrrrr
				// par contre jsp si c une bonne idée de find si jamais y'a plusieurs channels remove en même temps mais bon
				const idRemoved = this.channelOverrides.findKey((override, channelId) => !data[key].find(channel => channel["channel_id"] === channelId));
				// if (this.client.status === 0) console.log("idRemoved", idRemoved);
				if (idRemoved && this.client.status === 0) this.channelOverrides.delete(idRemoved);
				for (const channel of data[key]) {
					/*
					if (channel && channel.id === "1124664480073252895") {
						if (this.client.status === 0) console.log("[patch] group patched");
					}
					if (channel.muted && !this.client._muted.has(channel["channel_id"])) {
						this.client._muted.set(channel["channel_id"], channel);
					}*/
					this.channelOverrides.set(channel.channel_id, new ClientUserChannelOverride(channel));
				}
			} else if (typeof value === 'function') {
				this[value.name] = value(data[key]);
			} else {
				/*
				if (this.client.status === 0) console.log("[patch] imagine");
				if (this.client.status === 0) console.log("[patch] key", key);
				if (this.client.status === 0) console.log("[patch] oldvalue", value);
				if (this.client.status === 0) console.log("[patch] newvalue", data[key]);
				*/
				this[value] = data[key];
			}
		}
	}

	/**
	 * Update a specific property of the guild settings.
	 * @param {string} name Name of property
	 * @param {value} value Value to patch
	 * @returns {Promise<Object>}
	 */
	update(name, value) {
		return this.client.rest.methods.patchClientUserGuildSettings(this.guildID, { [name]: value });
	}
}

module.exports = ClientUserGuildSettings;
